https://platform.claude.com/docs/en/agent-sdk/python#edit

https://platform.openai.com/docs/quickstart?context=python&language=python


https://platform.openai.com/docs/guides/streaming-responses?api-mode=chat


https://context7.com/openai/openai-python




# Anthropic流式获得token
                
# 检查是否有usage信息（通常在最后一个chunk中）
                if hasattr(chunk, 'usage'):#anthropic的token统计在这里
                    usage = TokenUsage(
                        prompt_tokens=chunk.usage["prompt_tokens"],
                        completion_tokens=chunk.usage["completion_tokens"],
                        total_tokens=chunk.usage["total_tokens"]
                    )

# openai 获得token
count_response = client.responses.input_tokens.count(
    model="gpt-4o",
    input=[
        {"role": "user", "content": [{"type": "input_text", "text": "Hello"}]},
        {"role": "assistant", "content": [{"type": "output_text", "text": "Hi there!"}]},
        {"role": "user", "content": [{"type": "input_text", "text": "How are you?"}]},
    ],
)
print(f"Conversation tokens: {count_response.total_tokens}")



# openai tool call

在 OpenAI Python Library 中，**Tool Call（工具调用）** 是让模型根据需求主动调用外部工具（如函数、API、数据库查询等）的核心能力，主要通过 `Chat Completions API`/`Responses API` 结合 `tools`、`tool_choice` 等参数实现，以下是完整的使用方法、参数说明和实战示例：

### 一、核心参数说明
Tool Call 主要依赖以下参数（以 Chat Completions API 为例，Responses API 用法一致）：

| 参数名         | 类型          | 必选/可选 | 核心作用                                                                 |
|----------------|---------------|-----------|--------------------------------------------------------------------------|
| `tools`        | List[dict]    | 可选      | 定义模型可调用的工具列表，每个工具需描述名称、功能、参数结构（JSON Schema） |
| `tool_choice`  | str/dict      | 可选      | 指定模型是否/调用哪个工具：<br>- `auto`（默认）：模型自主决定是否调用<br>- `none`：不调用任何工具<br>- `{"type":"function","function":{"name":"工具名"}}`：强制调用指定工具 |
| `messages`     | List[dict]    | 必选      | 对话历史，需包含用户提问，若有工具调用结果，需追加 `tool_call`/`tool_result` 类型的消息 |
| `model`        | str           | 必选      | 需使用支持工具调用的模型（如 gpt-4o、gpt-4-turbo、gpt-5.2 等）|

#### `tools` 参数的详细结构（核心）
每个工具是一个字典，包含以下字段：
```python
{
    "type": "function",  # 固定值，目前仅支持 function 类型
    "function": {
        "name": "get_weather",  # 工具名称（唯一标识，需和实际调用的函数名一致）
        "description": "根据城市名称查询实时天气",  # 模型理解工具用途的描述（关键，影响调用准确性）
        "parameters": {  # 工具参数的 JSON Schema 定义（模型据此生成参数）
            "type": "object",
            "properties": {
                "city": {
                    "type": "string",
                    "description": "城市名称，如北京、上海"
                },
                "unit": {
                    "type": "string",
                    "description": "温度单位，可选值：celsius（摄氏度）、fahrenheit（华氏度）",
                    "default": "celsius"
                }
            },
            "required": ["city"]  # 必填参数（模型必须生成的字段）
        }
    }
}
```

### 二、完整使用流程（三步法）
#### 步骤1：定义工具并调用模型获取工具调用指令
```python
from openai import OpenAI
import json

# 1. 初始化客户端
client = OpenAI(api_key=os.environ.get("OPENAI_API_KEY"))

# 2. 定义工具列表
tools = [
    {
        "type": "function",
        "function": {
            "name": "get_weather",
            "description": "根据城市名称查询实时天气",
            "parameters": {
                "type": "object",
                "properties": {
                    "city": {"type": "string", "description": "城市名称"},
                    "unit": {"type": "string", "description": "温度单位，默认摄氏度", "default": "celsius"}
                },
                "required": ["city"]
            }
        }
    }
]

# 3. 调用模型，触发工具调用
response = client.chat.completions.create(
    model="gpt-4o",
    messages=[{"role": "user", "content": "查询上海今天的天气"}],
    tools=tools,  # 传入工具定义
    tool_choice="auto"  # 让模型自主决定是否调用工具
)

# 4. 解析模型返回的工具调用指令
message = response.choices[0].message
tool_calls = message.tool_calls  # 模型生成的工具调用列表（可能有多个）

if tool_calls:
    # 提取第一个工具调用的参数
    tool_call = tool_calls[0]
    function_name = tool_call.function.name
    function_args = json.loads(tool_call.function.arguments)
    print(f"模型要求调用工具：{function_name}")
    print(f"调用参数：{function_args}")  # 输出：{"city":"上海","unit":"celsius"}
```

#### 步骤2：执行本地/外部工具（模拟天气查询函数）
```python
# 模拟外部工具：天气查询函数
def get_weather(city: str, unit: str = "celsius") -> dict:
    # 实际场景中可替换为调用天气API
    mock_weather = {
        "北京": {"temperature": 15, "condition": "晴", "unit": "celsius"},
        "上海": {"temperature": 20, "condition": "多云", "unit": "celsius"}
    }
    return mock_weather.get(city, {"error": "城市未找到"})

# 执行工具调用
if tool_calls:
    for tool_call in tool_calls:
        func_name = tool_call.function.name
        func_args = json.loads(tool_call.function.arguments)
        
        # 根据工具名称执行对应函数
        if func_name == "get_weather":
            weather_result = get_weather(**func_args)
            print(f"工具执行结果：{weather_result}")  # 输出：{"temperature":20,"condition":"多云","unit":"celsius"}
```

#### 步骤3：将工具结果返回模型，生成最终回答
```python
# 5. 构造包含工具结果的消息，追加到对话历史
messages.append(message)  # 追加模型的工具调用消息
messages.append({
    "role": "tool",  # 固定角色：tool
    "content": json.dumps(weather_result),  # 工具执行结果（需序列化）
    "tool_call_id": tool_call.id  # 关联对应的工具调用ID（关键，模型需匹配）
})

# 6. 再次调用模型，基于工具结果生成最终回答
final_response = client.chat.completions.create(
    model="gpt-4o",
    messages=messages
)

print("最终回答：", final_response.choices[0].message.content)
# 输出：上海今天的天气为多云，温度20摄氏度。
```

### 三、高级用法与参数扩展
#### 1. 强制调用指定工具（`tool_choice` 精准控制）
```python
response = client.chat.completions.create(
    model="gpt-4o",
    messages=[{"role": "user", "content": "查询天气"}],
    tools=tools,
    # 强制调用 get_weather 工具
    tool_choice={"type": "function", "function": {"name": "get_weather"}}
)
```

四、核心总结
需求场景	推荐 tool_choice 取值
通用场景，让模型自主决策	"auto"（默认）
确定无需工具，直接回答	"none"
强制调用某个特定工具	{"type":"function", "function":{"name":"工具名"}}


#### 2. 多工具调用（定义多个工具）
```python
tools = [
    # 工具1：天气查询
    {
        "type": "function",
        "function": {
            "name": "get_weather",
            "description": "查询城市天气",
            "parameters": {...}
        }
    },
    # 工具2：股票查询
    {
        "type": "function",
        "function": {
            "name": "get_stock_price",
            "description": "查询股票代码对应的实时价格",
            "parameters": {
                "type": "object",
                "properties": {
                    "stock_code": {"type": "string", "description": "股票代码，如600000"}
                },
                "required": ["stock_code"]
            }
        }
    }
]

# 模型会根据用户问题选择对应的工具
response = client.chat.completions.create(
    model="gpt-4o",
    messages=[{"role": "user", "content": "查询茅台的股价和北京的天气"}],
    tools=tools
)
```

#### 3. 结合 Streaming 流式返回工具调用
```python
# 流式获取工具调用指令
stream = client.chat.completions.create(
    model="gpt-4o",
    messages=[{"role": "user", "content": "查询深圳天气"}],
    tools=tools,
    stream=True
)

for chunk in stream:
    if chunk.choices[0].delta.tool_calls:
        # 解析流式返回的工具调用参数
        tool_call_delta = chunk.choices[0].delta.tool_calls[0]
        print("流式工具调用参数：", tool_call_delta.function.arguments)
```

#### 4. Responses API 中的工具调用（结构化输出）
```python
from pydantic import BaseModel

# 定义工具调用结果的结构化模型
class WeatherResponse(BaseModel):
    city: str
    temperature: int
    condition: str

# 使用 Responses API 结合工具调用 + 结构化解析
response = client.responses.parse(
    model="gpt-4o",
    input="查询广州天气并返回结构化数据",
    tools=tools,
    text_format=WeatherResponse  # 指定输出结构
)
print("结构化工具结果：", response.output[0].content[0].parsed)
```

### 四、关键注意事项
1. **模型兼容性**：仅 gpt-3.5-turbo-1106、gpt-4、gpt-4o、gpt-5.1/5.2 等模型支持工具调用，基础模型（如 gpt-3.5-turbo-0613）需确认版本；
2. **参数校验**：`parameters` 的 JSON Schema 需准确（必填字段、类型），否则模型可能生成无效参数；
3. **tool_call_id 关联**：返回工具结果时必须携带 `tool_call_id`，否则模型无法匹配结果；
4. **错误处理**：工具执行失败时，需返回错误信息（如 `{"error": "接口超时"}`），模型会据此生成友好提示；
5. **MCP 工具支持**：新版本库支持 MCP（Model Context Protocol）工具，需在 `tools` 中增加 `mcp` 类型，并配置 `approval_requests` 实现调用审批。

### 五、完整可运行示例
```python
import os
import json
from openai import OpenAI

# 初始化客户端
client = OpenAI(api_key=os.environ.get("OPENAI_API_KEY"))

# 1. 定义工具
tools = [
    {
        "type": "function",
        "function": {
            "name": "get_weather",
            "description": "根据城市名称查询实时天气",
            "parameters": {
                "type": "object",
                "properties": {
                    "city": {"type": "string", "description": "城市名称"},
                    "unit": {"type": "string", "description": "温度单位，默认celsius"}
                },
                "required": ["city"]
            }
        }
    }
]

# 2. 第一步调用：获取工具调用指令
first_response = client.chat.completions.create(
    model="gpt-4o",
    messages=[{"role": "user", "content": "杭州今天的天气

# 等效
你观察到的这个细节非常关键！核心结论先明确：
`messages.append(message)` 不用手动转格式，因为 `message` 本身就是**符合 OpenAI 消息规范的结构化对象**；而 `role="tool"` 的消息是我们手动构造的字典，两者格式本质上是统一的，只是来源不同。

下面拆解清楚「格式一致性」和「为什么不用手动转 `assistant` 角色」：

### 一、先看 `message` 的真实结构（核心关键）
`message = response.choices[0].message` 并不是普通字符串，而是 OpenAI 库返回的 `ChatCompletionMessage` 对象，它的底层结构等价于这样的字典：
```python
# message 对象的等效字典格式
{
    "role": "assistant",  # 固定为assistant（模型生成的消息）
    "content": None,      # 工具调用时content为None（因为模型没直接回答）
    "tool_calls": [       # 工具调用指令列表
        {
            "id": "call_xxx",
            "type": "function",
            "function": {
                "name": "get_weather",
                "arguments": '{"city":"上海，北京"}'
            }
        }
    ]
}
```
所以 `messages.append(message)` 本质上是把「模型生成的、符合 OpenAI 消息规范的 `assistant` 角色消息」追加到对话历史里，格式完全合规，不需要手动修改。

### 二、两个 `append` 的格式对比（本质统一）
| 代码行 | 内容类型 | 等效字典格式 | 核心作用 |
|--------|----------|--------------|----------|
| `messages.append(message)` | OpenAI 库返回的 `ChatCompletionMessage` 对象 | `{"role":"assistant", "content":None, "tool_calls":[...]}` | 记录模型的「工具调用指令」，让后续调用知道模型之前的决策 |
| `messages.append({"role":"tool", ...})` | 手动构造的字典 | `{"role":"tool", "content":"JSON字符串", "tool_call_id":"call_xxx"}` | 回填「工具执行结果」，关联对应的工具调用ID |

#### 关键说明：
1. **`role` 类型不同是故意的**：
   - `assistant` 角色：代表「模型生成的消息」（这里是工具调用指令）；
   - `tool` 角色：代表「工具执行的结果」（必须和 `tool_call_id` 绑定）；
   OpenAI 协议要求：工具调用的闭环必须是「user → assistant（tool_calls） → tool（结果） → assistant（最终回答）」，两者角色不能混用。

2. **为什么 `message` 不用手动转格式**：
   OpenAI Python 库做了「对象转字典」的底层兼容——当你把 `ChatCompletionMessage` 对象传入 `messages` 列表时，库会自动将其序列化为 API 能识别的字典格式，无需手动处理。

### 三、验证：打印 `messages` 看真实格式
在 `messages.append(message)` 后加一行打印，就能看到格式一致性：
```python
# 追加后打印 messages
print("追加assistant消息后的messages：")
for msg in messages:
    print(msg)

# 输出示例（简化版）：
# [
#   {"role":"user", "content":"查询上海，北京的天气"},
#   {"role":"assistant", "content":None, "tool_calls":[...]}
# ]
```
可以看到：`message` 被自动转为了和手动构造的 `tool` 消息同格式的字典，只是 `role` 和字段不同。

### 四、如果手动改 `assistant` 角色会怎样？
假设你强行把 `message` 改成其他格式：
```python
# 错误示例：手动改role
bad_message = {
    "role": "user",  # 错误：模型生成的消息不能是user角色
    "content": "调用get_weather工具"
}
messages.append(bad_message)
```
后续调用模型时，模型会误解对话历史（以为是用户发的消息），导致工具结果无法关联，最终回答错误。

### 五、核心总结
1. `messages.append(message)` 不用手动转格式的原因：
   - `message` 是 OpenAI 库返回的合规对象，库会自动序列化；
   - 其 `role="assistant"` 是模型生成消息的默认角色，符合工具调用协议。

2. 两个 `append` 的格式看似不同，实则都是遵循 OpenAI 消息规范：
   - 一个是「模型的工具调用指令」（assistant 角色）；
   - 一个是「工具的执行结果」（tool 角色）；
   两者配合形成完整的工具调用闭环，缺一不可。

简单说：OpenAI 工具调用的对话历史必须严格遵循「角色+内容」的规范，`message` 本身已经是合规的 `assistant` 消息，而 `tool` 消息是我们按规范手动构造的，两者格式统一、角色互补。



----------
查看所有消息格式：


[2 tools called]


所有消息格式如下：

## 1. **system** 消息
```python
{
    "role": "system",
    "content": "系统提示词内容，定义agent的行为和规则"
}
```
- 在 `run()` 开始时添加（第112行）
- 只有 `role` 和 `content` 两个字段

## 2. **user** 消息
```python
{
    "role": "user",
    "content": "用户的输入问题或指令"
}
```
- 在 `run()` 开始时添加（第115行）
- 只有 `role` 和 `content` 两个字段

## 3. **assistant** 消息（有 tool_calls）
```python
{
    "role": "assistant",
    "content": "可能需要调用工具来获取信息",  # 可能为空字符串
    "tool_calls": [
        {
            "id": "call_abc123",
            "type": "function",
            "function": {
                "name": "read_file",
                "arguments": "{\"path\": \"/path/to/file\"}"
            }
        }
    ]
}
```
- 模型决定调用工具时添加（第155-159行）
- 包含 `tool_calls` 数组，每个元素包含 `id`、`type`、`function`（`name` 和 `arguments`）

## 4. **assistant** 消息（无 tool_calls）
```python
{
    "role": "assistant",
    "content": "根据工具结果，这是最终答案..."
}
```
- 模型给出最终答案时添加（第200-203行）
- 只有 `role` 和 `content`，没有 `tool_calls`

## 5. **tool** 消息（工具执行结果）
```python
{
    "role": "tool",
    "content": "{\"result\": \"文件内容...\"}",  # JSON字符串格式
    "tool_call_id": "call_abc123"
}
```
- 工具执行完成后添加（第177-181行）
- `content` 是 JSON 字符串，包含工具执行结果
- `tool_call_id` 对应 assistant 消息中 `tool_calls` 的 `id`

## 6. **tool** 消息（工具执行错误）
```python
{
    "role": "tool",
    "content": "{\"error\": \"Tool 'xxx' not found\"}",  # JSON字符串格式
    "tool_call_id": "call_abc123"
}
```
- 工具未找到或执行失败时添加（第188-192行）
- 格式与成功结果相同，但 `content` 包含错误信息

---

**消息流转顺序示例：**
1. `system` → 系统提示
2. `user` → 用户问题
3. `assistant`（有 tool_calls）→ 模型决定调用工具
4. `tool` → 工具执行结果
5. `assistant`（有 tool_calls）→ 可能继续调用工具
6. `tool` → 工具执行结果
7. `assistant`（无 tool_calls）→ 最终答案

所有消息最终通过 `session.get_messages()` 转换为字典列表，发送给 LLM API。